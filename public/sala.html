const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const path = require('path');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
    cors: {
        origin: "*", // Permitir de qualquer origem durante o desenvolvimento
        methods: ["GET", "POST"]
    }
});

app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

const users = []; // Temporário; use um banco de dados em produção.
let patientQueue = []; // Fila de pacientes na memória do servidor
let currentlyCallingPatient = null; // Paciente sendo chamado no momento
let youtubePlaylistUrl = null; // URL da playlist do YouTube ou null
let connectedProfessionals = {}; // Profissionais conectados: { socketId: { name: 'Nome', role: 'Role' } }

// --- ROTAS DE AUTENTICAÇÃO ---

// Registro de usuário
app.post('/register', async (req, res) => {
    const { username, password, role } = req.body;

    // Hash da senha
    const hashedPassword = await bcrypt.hash(password, 10);
    users.push({ username, password: hashedPassword, role });

    res.status(201).send('Usuário registrado com sucesso!');
});

// Login de usuário
app.post('/login', async (req, res) => {
    const { username, password } = req.body;
    const user = users.find(u => u.username === username);

    if (!user || !(await bcrypt.compare(password, user.password))) {
        return res.status(401).send('Credenciais inválidas');
    }

    // Geração do JWT
    const token = jwt.sign({ username: user.username, role: user.role }, 'secret_key', { expiresIn: '1h' });
    res.json({ token });
});

// Rota protegida
app.get('/dashboard', (req, res) => {
    const authHeader = req.headers.authorization;

    if (!authHeader) return res.status(401).send('Token não fornecido');

    const token = authHeader.split(' ')[1];
    try {
        const decoded = jwt.verify(token, 'secret_key');
        res.json({ message: `Bem-vindo, ${decoded.username}!`, role: decoded.role });
    } catch {
        res.status(403).send('Token inválido');
    }
});

// --- SOCKET.IO ---

io.on('connection', (socket) => {
    console.log('Novo cliente conectado:', socket.id);

    // Enviar estado inicial para cliente
    socket.emit('current_state', {
        patients: patientQueue,
        calling: currentlyCallingPatient,
        playlistUrl: youtubePlaylistUrl,
        professionals: Object.values(connectedProfessionals)
    });

    // Login de profissional
    socket.on('professional_login', (professionalInfo) => {
        if (!professionalInfo || !professionalInfo.name || !professionalInfo.role) {
            socket.emit('error_message', 'Informações de login inválidas.');
            return;
        }
        connectedProfessionals[socket.id] = professionalInfo;
        console.log(`Profissional "${professionalInfo.name}" (${professionalInfo.role}) logado (ID: ${socket.id}).`);
        io.emit('professional_list_updated', Object.values(connectedProfessionals));
    });

    // Logout de profissional
    socket.on('professional_logout', () => {
        const professionalInfo = connectedProfessionals[socket.id];
        if (professionalInfo) {
            delete connectedProfessionals[socket.id];
            console.log(`Profissional "${professionalInfo.name}" (${professionalInfo.role}) deslogado (ID: ${socket.id}).`);
            io.emit('professional_list_updated', Object.values(connectedProfessionals));

            if (currentlyCallingPatient && currentlyCallingPatient.calledBySocketId === socket.id) {
                currentlyCallingPatient = null;
                io.emit('call_stopped');
                console.log(`Chamada parada pois o profissional "${professionalInfo.name}" deslogou.`);
            }
        }
    });

    // Adicionar paciente
    socket.on('add_patient', (patientData) => {
        const professionalInfo = connectedProfessionals[socket.id];
        if (!professionalInfo) {
            socket.emit('error_message', 'Você precisa estar logado para adicionar pacientes.');
            return;
        }

        if (!patientData || !patientData.name) {
            socket.emit('error_message', 'Dados do paciente inválidos.');
            return;
        }

        const newPatient = {
            id: 'patient_' + Date.now(),
            name: patientData.name,
            priority: patientData.priority || 'normal',
            addedTime: Date.now(),
            addedBy: professionalInfo,
            addedBySocketId: socket.id
        };
        patientQueue.push(newPatient);
        sortPatientQueue();
        io.emit('queue_updated', patientQueue);
        console.log(`Paciente "${newPatient.name}" adicionado por "${professionalInfo.name}" (${professionalInfo.role}).`);
    });

    // Chamar paciente
    socket.on('call_patient', (patientId) => {
        const professionalInfo = connectedProfessionals[socket.id];
        if (!professionalInfo) {
            socket.emit('error_message', 'Você precisa estar logado para chamar pacientes.');
            return;
        }

        const patientIndex = patientQueue.findIndex(p => p.id === patientId);

        if (patientIndex !== -1 && !currentlyCallingPatient) {
            const patientToCall = patientQueue[patientIndex];

            // Verificação de autorização para chamar o paciente
            if (patientToCall.addedBySocketId !== socket.id) {
                socket.emit('error_message', 'Você só pode chamar pacientes que você adicionou à fila.');
                console.log(`Tentativa falha de chamar paciente "${patientToCall.name}" por outro profissional.`);
                return;
            }

            patientQueue.splice(patientIndex, 1);

            currentlyCallingPatient = {
                ...patientToCall,
                calledBy: professionalInfo,
                calledBySocketId: socket.id
            };

            io.emit('queue_updated', patientQueue);
            io.emit('patient_called', currentlyCallingPatient);
            console.log(`Paciente "${patientToCall.name}" chamado por "${professionalInfo.name}" (${professionalInfo.role}).`);
        } else if (currentlyCallingPatient) {
            socket.emit('error_message', `Já há um paciente sendo chamado: ${currentlyCallingPatient.name}.`);
        } else {
            socket.emit('error_message', 'Paciente não encontrado na fila.');
        }
    });

    // Confirmar ou cancelar chamada
    socket.on('confirm_or_stop_call', (data) => {
        const professionalInfo = connectedProfessionals[socket.id];
        if (!professionalInfo) {
            socket.emit('error_message', 'Você precisa estar logado para encerrar chamadas.');
            return;
        }

        if (currentlyCallingPatient && currentlyCallingPatient.id === data.patientId) {
            if (currentlyCallingPatient.calledBySocketId === socket.id) {
                if (data.confirmed) {
                    console.log(`Chegada de "${currentlyCallingPatient.name}" confirmada por "${professionalInfo.name}".`);
                } else {
                    console.log(`Chamada de "${currentlyCallingPatient.name}" parada por "${professionalInfo.name}".`);
                }
                currentlyCallingPatient = null;
                io.emit('call_stopped');
                io.emit('queue_updated', patientQueue);
            } else {
                socket.emit('error_message', 'Você só pode encerrar chamadas que você iniciou.');
            }
        } else {
            socket.emit('error_message', 'Nenhum paciente ativo para encerrar a chamada.');
        }
    });

    // Atualizar vídeo ou playlist
    socket.on('update_video', (url) => {
        const professionalInfo = connectedProfessionals[socket.id];
        if (!professionalInfo) {
            socket.emit('error_message', 'Você precisa estar logado para atualizar o vídeo.');
            return;
        }
        const playlistRegex = /^(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/playlist\?list=|youtu\.be\/.*?[?&]list=)([a-zA-Z0-9_-]+)/;
        const match = url ? url.match(playlistRegex) : null;

        if (url && match) {
            const playlistId = match[1];
            youtubePlaylistUrl = `https://www.youtube.com/embed/videoseries?list=${playlistId}&autoplay=1&mute=1&loop=1`;
            io.emit('video_updated', youtubePlaylistUrl);
            console.log(`Playlist do YouTube atualizada por "${professionalInfo.name}": ${youtubePlaylistUrl}`);
        } else if (!url) {
            youtubePlaylistUrl = null;
            io.emit('video_updated', youtubePlaylistUrl);
            console.log(`Vídeo/Playlist removido por "${professionalInfo.name}".`);
        } else {
            socket.emit('error_message', 'Link inválido. Use um link completo de uma playlist do YouTube.');
        }
    });

    // Desconexão
    socket.on('disconnect', () => {
        const professionalInfo = connectedProfessionals[socket.id];
        if (professionalInfo) {
            delete connectedProfessionals[socket.id];
            console.log(`Profissional "${professionalInfo.name}" desconectado (ID: ${socket.id}).`);
            io.emit('professional_list_updated', Object.values(connectedProfessionals));

            if (currentlyCallingPatient && currentlyCallingPatient.calledBySocketId === socket.id) {
                currentlyCallingPatient = null;
                io.emit('call_stopped');
                console.log(`Chamada parada pois o profissional "${professionalInfo.name}" desconectou inesperadamente.`);
            }
        } else {
            console.log('Cliente desconectado (sem login):', socket.id);
        }
    });
});

// Função para ordenar a fila de pacientes
function sortPatientQueue() {
    patientQueue.sort((a, b) => {
        if (a.priority === 'high' && b.priority !== 'high') return -1;
        if (b.priority === 'high' && a.priority !== 'high') return 1;
        return a.addedTime - b.addedTime;
    });
}

// Rota inicial
app.get('/', (req, res) => {
    res.redirect('/medico.html');
});

// Inicialização do servidor
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`Servidor rodando em http://localhost:${PORT}`);
});
